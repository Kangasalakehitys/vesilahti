[
  {
    "objectID": "verotus.html",
    "href": "verotus.html",
    "title": "Verotus",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "verotus.html#väestönmuutokset---väestöennakko-kolme-ikäluokkaa",
    "href": "verotus.html#väestönmuutokset---väestöennakko-kolme-ikäluokkaa",
    "title": "Verotus",
    "section": "Väestönmuutokset - Väestöennakko, kolme ikäluokkaa",
    "text": "Väestönmuutokset - Väestöennakko, kolme ikäluokkaa\nKuntaliitto käyttää kunnallisveron perustana kolmea ikäluokkaa. Ikäluokittelu huomioi palkansaajat ja eläkeläiset.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVuosi\nYhteensä\n0-18\n0-18 %\n19-64\n19-64 %\n65+\n65+ %\n\n\n\n\n2000\n3421\n901\n26.34\n1910\n55.83\n610\n17.83\n\n\n2001\n3481\n939\n26.98\n1928\n55.39\n614\n17.64\n\n\n2002\n3596\n988\n27.47\n1989\n55.31\n619\n17.21\n\n\n2003\n3663\n1022\n27.90\n2038\n55.64\n603\n16.46\n\n\n2004\n3675\n1026\n27.92\n2037\n55.43\n612\n16.65\n\n\n2005\n3831\n1098\n28.66\n2109\n55.05\n624\n16.29\n\n\n2006\n3949\n1138\n28.82\n2176\n55.10\n635\n16.08\n\n\n2007\n4086\n1190\n29.12\n2252\n55.12\n644\n15.76\n\n\n2008\n4248\n1253\n29.50\n2346\n55.23\n649\n15.28\n\n\n2009\n4365\n1273\n29.16\n2441\n55.92\n651\n14.91\n\n\n2010\n4345\n1268\n29.18\n2407\n55.40\n670\n15.42\n\n\n2011\n4383\n1270\n28.98\n2429\n55.42\n684\n15.61\n\n\n2012\n4437\n1274\n28.71\n2478\n55.85\n685\n15.44\n\n\n2013\n4473\n1292\n28.88\n2462\n55.04\n719\n16.07\n\n\n2014\n4492\n1309\n29.14\n2439\n54.30\n744\n16.56\n\n\n2015\n4489\n1287\n28.67\n2438\n54.31\n764\n17.02\n\n\n2016\n4462\n1252\n28.06\n2444\n54.77\n766\n17.17\n\n\n2017\n4460\n1250\n28.03\n2418\n54.22\n792\n17.76\n\n\n2018\n4393\n1192\n27.13\n2394\n54.50\n807\n18.37\n\n\n2019\n4355\n1153\n26.48\n2384\n54.74\n818\n18.78\n\n\n2020\n4367\n1129\n25.85\n2417\n55.35\n821\n18.80\n\n\n2021\n4444\n1119\n25.18\n2471\n55.60\n854\n19.22\n\n\n2022\n4501\n1130\n25.11\n2500\n55.54\n871\n19.35\n\n\n2023\n4469\n1106\n24.75\n2489\n55.69\n874\n19.56\n\n\n2024M12*\n4515\n1117\n24.74\n2496\n55.28\n902\n19.98\n\n\n\n\n\n\n\n\nVäestökehityksen muutos - kolme ikäluokkaa\n\n0-18-vuotiaat\nIkäluokkien kehitystä aikaisempiin vuosiin vertailtaessa 0-18-vuotiaiden %-osuus oli 2024M12* yhteensä 24.74. Jos verrataan lukemaa kahteen edellisvuoteen 2022 ja 2023, muutosta on tullut -0.37 (2022) ja -0.01 (2023)\n\n\n19-64-vuotiaat\n19-64-vuotiaiden palkansaajien %-osuus oli 2024M12* yhteensä 55.28. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut -0.26 (2022) ja -0.41 (2023)\n\n\n65+-vuotiaat\n65+-vuotiaiden eläkeläisten prosenttiosuus kokonaisuudesta oli 2024M12* yhteensä 19.98. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.63 (2022) ja 0.42 (2023 )"
  },
  {
    "objectID": "verotus.html#ansiotulot",
    "href": "verotus.html#ansiotulot",
    "title": "Verotus",
    "section": "Ansiotulot",
    "text": "Ansiotulot\nTilasto sisältää tuloverotuksen valmistumisen mukaiset tiedot kaikista henkilöasiakkaista. Tilastossa ei huomioida muutosverotuksen tietoja. Lähde: (Vero.fi 2024a)\n\n\n\n\n\n\n\n\nVuosi\nPalkkatulot\nPM %\nEläketulot\nEM %\nTyöttömyysturva\nTM %\nMuut sos.turva\nMM %\nMaa- ja metsätalous\nMTM %\nElinkeinotoiminta\nELM %\nAnsiotulot\nAM %\n\n\n\n\n2014\n65,099,471\nNA\n16,141,490\nNA\n3,331,064\nNA\n2,048,487\nNA\n1,554,507\nNA\n5,000,574\nNA\n93,175,593\nNA\n\n\n2015\n66,200,394\n1.69\n16,581,444\n2.73\n3,589,994\n7.77\n2,166,228\n5.75\n1,435,718\n-7.64\n5,206,319\n4.11\n95,180,097\n2.15\n\n\n2016\n68,210,430\n3.04\n17,025,529\n2.68\n3,553,469\n-1.02\n2,008,264\n-7.29\n1,290,834\n-10.09\n5,109,950\n-1.85\n97,198,476\n2.12\n\n\n2017\n69,081,229\n1.28\n17,659,146\n3.72\n3,031,355\n-14.69\n2,029,211\n1.04\n1,138,166\n-11.83\n4,750,141\n-7.04\n97,689,248\n0.50\n\n\n2018\n72,595,474\n5.09\n18,333,687\n3.82\n2,295,314\n-24.28\n2,187,888\n7.82\n1,159,036\n1.83\n4,890,222\n2.95\n101,461,621\n3.86\n\n\n2019\n73,610,209\n1.40\n19,332,215\n5.45\n2,241,983\n-2.32\n2,365,411\n8.11\n1,273,085\n9.84\n4,836,765\n-1.09\n103,659,668\n2.17\n\n\n2020\n74,381,124\n1.05\n19,912,761\n3.00\n3,162,013\n41.04\n2,237,297\n-5.42\n1,090,813\n-14.32\n4,546,510\n-6.00\n105,330,518\n1.61\n\n\n2021\n80,519,419\n8.25\n20,135,737\n1.12\n2,785,942\n-11.89\n2,335,406\n4.39\n1,050,906\n-3.66\n4,869,762\n7.11\n111,697,172\n6.04\n\n\n2022\n87,198,575\n8.30\n20,829,404\n3.44\n2,229,937\n-19.96\n2,700,769\n15.64\n1,045,315\n-0.53\n5,751,325\n18.10\n119,755,325\n7.21\n\n\n2023\n94,008,089\n7.81\n22,838,258\n9.64\n2,190,471\n-1.77\n2,801,028\n3.71\n1,028,016\n-1.65\n5,612,419\n-2.42\n128,478,281\n7.28\n\n\n\n\n\n\n\n\nAnsiotulojen kehitys\nPalkkatulot olivat vuonna 2023 yhteensä 94,008,089. Muutos edelliseen 2022 vuoteen oli 7.81. Eläketulojen osalta muutos oli 9.64 (9.64)"
  },
  {
    "objectID": "verotus.html#vähennykset",
    "href": "verotus.html#vähennykset",
    "title": "Verotus",
    "section": "Vähennykset",
    "text": "Vähennykset\nTilaston vähennyseristä yleisesti: Jos verovelvolliselle ei ole määrätty verotettavasta tulosta veroja tai niiden määrä on pienempi kuin verosta myönnetty vähennys, myönnettyä vähennystä ei ole voitu vähentää kokonaisuudessaan. Tällaisissa tilanteissa verotuksessa vähennetty määrä on pienempi kuin myönnetty määrä. Sama periaate pätee myös tuloista tehtävien vähennysten osalta.\n*Lyhenteet:\n\nPV % = Palkansaajan vakuutusmaksujen %-osuus palkoista\n\nE % = Eläketulovähennyksen %-osuus eläkkeistä\n\nA % = Vuosittainen muutos ansiotulot-vähennykset*\nLähde: (Vero.fi 2024a)\n\n\n\n\n\n\n\n\nVuosi\nPalkansaajan vak.maksut\nPV %\nVähennetyt matkakustan.\nMuut tulonhankk.vähenn.\nEläketulovähennys\nE %\nAnsiotulovähennys\nPerusvähennys\nMuut vähennykset\nVähennykset yht.\nVäh.aste\nAnsiotulot-vähennykset\nA %\n\n\n\n\n2014\n32,996,182\n7.02\n10,515,057\n14,740,244\n29,893,588\n20.78\n34,332,906\n13,520,629\n1,159,157\n137,157,763\n20.01\n548,401,114\nNA\n\n\n2015\n34,527,129\n7.20\n9,663,164\n15,031,407\n31,568,620\n21.34\n33,810,533\n14,495,603\n1,208,690\n140,305,146\n20.08\n558,316,669\n1.81\n\n\n2016\n37,558,214\n7.62\n9,287,428\n15,268,526\n31,180,264\n20.49\n33,660,485\n14,817,154\n1,096,444\n142,868,515\n19.94\n573,607,853\n2.74\n\n\n2017\n46,673,871\n9.22\n9,407,284\n17,462,760\n32,018,808\n20.25\n34,672,097\n15,623,217\n1,059,448\n156,917,485\n21.42\n575,774,142\n0.38\n\n\n2018\n51,373,340\n9.63\n10,193,385\n17,863,570\n31,642,727\n19.43\n35,249,532\n16,019,546\n1,075,751\n163,417,851\n21.46\n598,103,526\n3.88\n\n\n2019\n53,811,966\n9.62\n10,486,576\n18,326,137\n31,212,577\n18.49\n35,593,000\n17,848,170\n1,070,505\n168,348,931\n21.25\n624,002,295\n4.33\n\n\n2020\n52,738,391\n9.44\n9,383,158\n18,754,058\n31,925,351\n18.16\n34,894,932\n20,412,225\n1,173,984\n169,282,099\n21.00\n636,792,368\n2.05\n\n\n2021\n57,807,221\n9.72\n9,953,689\n19,456,911\n32,233,771\n17.85\n35,216,206\n21,437,603\n1,109,425\n177,214,826\n20.92\n669,774,841\n5.18\n\n\n2022\n61,446,316\n9.61\n12,921,131\n19,888,239\n34,528,157\n18.46\n36,329,798\n22,238,701\n1,100,596\n188,452,938\n21.02\n708,271,407\n5.75"
  },
  {
    "objectID": "verotus.html#kiinteistövero",
    "href": "verotus.html#kiinteistövero",
    "title": "Verotus",
    "section": "Kiinteistövero",
    "text": "Kiinteistövero\nKunnan alueella sijaitsevista kiinteistöistä maksuunpantu kiinteistövero tilitetään kokonaisuudessaan kyseiselle kunnalle. Tilaston avulla voi arvioida kunnan kiinteistöverotuottojen suuruutta. Tilastoluvut eivät kuitenkaan kerro aivan tarkasti kunnille todellisuudessa tilitetyistä kiinteistöverotuotoista, koska maksuunpannun kiinteistöveron määrä voi muuttua muutosverotuksen myötä ja nämä muutokset eivät päivity tilastolukuihin. Lisäksi maksuunpantua kiinteistöveroa ei välttämättä saada kokonaisuudessaan kerättyä. Lähde: (Vero.fi 2024b)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVuosi\nYhteensä\nLukumäärä\nMuutos %\n\n\n\n\n2014\n1,118,767\n4624\nNA\n\n\n2015\n1,128,018\n4633\n0.83\n\n\n2016\n1,152,384\n4646\n2.16\n\n\n2017\n1,264,912\n4664\n9.76\n\n\n2018\n1,251,014\n4680\n-1.10\n\n\n2019\n1,266,811\n4708\n1.26\n\n\n2020\n1,307,756\n4766\n3.23\n\n\n2021\n1,309,290\n4785\n0.12\n\n\n2022\n1,358,236\n4877\n3.74\n\n\n2023\n1,462,238\n4932\n7.66\n\n\n2024\n1,504,942\n4943\n2.92\n\n\n\n\n\n\n\n\nKiinteistöverojen kehitys\nKiinteistöverojen määrä oli vuonna 2024 yhteensä 1,504,942. Muutos edelliseen vuoteen 2023 oli 2.92."
  },
  {
    "objectID": "tyollisyys.html",
    "href": "tyollisyys.html",
    "title": "Työllisyys",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "tyollisyys.html#työttömien-työnhakijoiden--osuus-työvoimasta-koko-maassa-1",
    "href": "tyollisyys.html#työttömien-työnhakijoiden--osuus-työvoimasta-koko-maassa-1",
    "title": "Työllisyys",
    "section": "Työttömien työnhakijoiden %-osuus työvoimasta koko maassa",
    "text": "Työttömien työnhakijoiden %-osuus työvoimasta koko maassa\n\n\n\n\n\n\n\n\nSija\nMaakunta\nKunta\n2024M11\n\n\n\n\n1\nPohjanmaa\nLuoto\n2.4\n\n\n2\nAhvenanmaa\nBrändö\n2.7\n\n\n3\nAhvenanmaa\nFöglö\n2.7\n\n\n4\nPohjanmaa\nPedersören kunta\n2.9\n\n\n5\nAhvenanmaa\nSaltvik\n3.0\n\n\n6\nAhvenanmaa\nJomala\n3.1\n\n\n7\nPohjanmaa\nMaalahti\n3.2\n\n\n8\nAhvenanmaa\nLemland\n3.6\n\n\n9\nPohjanmaa\nMustasaari\n3.6\n\n\n10\nKeski-Pohjanmaa\nLestijärvi\n3.8\n\n\n11\nEtelä-Pohjanmaa\nEvijärvi\n3.9\n\n\n12\nPohjanmaa\nNärpiö\n4.0\n\n\n13\nAhvenanmaa\nGeta\n4.1\n\n\n14\nAhvenanmaa\nFinström\n4.4\n\n\n15\nEtelä-Pohjanmaa\nKuortane\n4.6\n\n\n16\nAhvenanmaa\nEckerö\n4.7\n\n\n17\nVarsinais-Suomi\nRusko\n4.7\n\n\n18\nVarsinais-Suomi\nMasku\n4.9\n\n\n19\nUusimaa\nInkoo\n5.0\n\n\n20\nPohjanmaa\nKruunupyy\n5.1\n\n\n21\nAhvenanmaa\nSund\n5.1\n\n\n22\nPohjanmaa\nUusikaarlepyy\n5.1\n\n\n23\nAhvenanmaa\nHammarland\n5.2\n\n\n24\nAhvenanmaa\nVårdö\n5.3\n\n\n25\nLappi\nUtsjoki\n5.4\n\n\n26\nPohjanmaa\nKorsnäs\n5.6\n\n\n27\nVarsinais-Suomi\nParainen\n5.6\n\n\n28\nVarsinais-Suomi\nNousiainen\n5.7\n\n\n29\nLappi\nSodankylä\n5.7\n\n\n30\nKeski-Pohjanmaa\nVeteli\n5.7\n\n\n31\nUusimaa\nSiuntio\n5.8\n\n\n32\nEtelä-Pohjanmaa\nIlmajoki\n5.9\n\n\n33\nEtelä-Pohjanmaa\nIsojoki\n5.9\n\n\n34\nPohjanmaa\nVöyri\n5.9\n\n\n35\nPohjanmaa\nKristiinankaupunki\n6.0\n\n\n36\nPohjanmaa\nLaihia\n6.0\n\n\n37\nVarsinais-Suomi\nLieto\n6.0\n\n\n38\nPohjois-Pohjanmaa\nMerijärvi\n6.0\n\n\n39\nVarsinais-Suomi\nPaimio\n6.1\n\n\n40\nEtelä-Pohjanmaa\nSoini\n6.1\n\n\n41\nPohjois-Pohjanmaa\nLiminka\n6.4\n\n\n42\nEtelä-Pohjanmaa\nAlajärvi\n6.5\n\n\n43\nKeski-Pohjanmaa\nKaustinen\n6.5\n\n\n44\nPirkanmaa\nKihniö\n6.5\n\n\n45\nEtelä-Pohjanmaa\nLappajärvi\n6.5\n\n\n46\nEtelä-Pohjanmaa\nVimpeli\n6.5\n\n\n47\nEtelä-Pohjanmaa\nKauhava\n6.6\n\n\n48\nEtelä-Pohjanmaa\nIsokyrö\n6.7\n\n\n49\nVarsinais-Suomi\nKaarina\n6.7\n\n\n50\nLappi\nKittilä\n6.7\n\n\n\n\n\n\n\n\nVertailu koko maan ja maakunnan osalta\nVesilahti on sijalla 75, tarkasteltaessa työttömien työnhakijoiden %-osuutta työvoimasta. Viimeisin ennakkotietolukema on 7.5. Maakuntavertailussa (Pirkanmaa) Vesilahti on sijalla 6."
  },
  {
    "objectID": "tyollisyys.html#työttömät-työnhakijat",
    "href": "tyollisyys.html#työttömät-työnhakijat",
    "title": "Työllisyys",
    "section": "Työttömät työnhakijat",
    "text": "Työttömät työnhakijat\n\nTyöttömät työnhakijat laskentapäivänä\n\n\n\n\n\n\nTilastokeskuksen työssäkäyntitilaston mukaan työttömiä työnhakijoita oli 2024M11 yhteensä 166 (lukema 2024M10: 164).\n\n\n\n\n\n\n\n\nKuukausi\nTyöttömät työnhakijat laskentapäivänä (lkm.)\n\n\n\n\n2022M12\n108\n\n\n2023M01\n107\n\n\n2023M02\n112\n\n\n2023M03\n111\n\n\n2023M04\n120\n\n\n2023M05\n117\n\n\n2023M06\n142\n\n\n2023M07\n142\n\n\n2023M08\n119\n\n\n2023M09\n130\n\n\n2023M10\n134\n\n\n2023M11\n145\n\n\n2023M12\n157\n\n\n2024M01\n159\n\n\n2024M02\n161\n\n\n2024M03\n150\n\n\n2024M04\n150\n\n\n2024M05\n136\n\n\n2024M06\n154\n\n\n2024M07\n166\n\n\n2024M08\n145\n\n\n2024M09\n157\n\n\n2024M10\n164\n\n\n2024M11\n166"
  },
  {
    "objectID": "tyollisyys.html#alle-25-v.-työttömät-työnhakijat",
    "href": "tyollisyys.html#alle-25-v.-työttömät-työnhakijat",
    "title": "Työllisyys",
    "section": "Alle 25-v. työttömät työnhakijat",
    "text": "Alle 25-v. työttömät työnhakijat\n\n\n\n\n\n\n:::\n\nAlle 25-v. työttömät työnhakijat (lkm.)\nAlle 25-vuotiaita työttömiä oli 2024M11 yhteensä 19 (lukema 2024M10: 19).\n\n\n\n\n\n\n\n\nKuukausi\nAlle 25-v. työttömät työnhakijat (lkm.)\n\n\n\n\n2022M12\n12\n\n\n2023M01\n9\n\n\n2023M02\n12\n\n\n2023M03\n12\n\n\n2023M04\n12\n\n\n2023M05\n11\n\n\n2023M06\n20\n\n\n2023M07\n19\n\n\n2023M08\n12\n\n\n2023M09\n15\n\n\n2023M10\n15\n\n\n2023M11\n14\n\n\n2023M12\n18\n\n\n2024M01\n21\n\n\n2024M02\n15\n\n\n2024M03\n11\n\n\n2024M04\n13\n\n\n2024M05\n12\n\n\n2024M06\n17\n\n\n2024M07\n17\n\n\n2024M08\n16\n\n\n2024M09\n15\n\n\n2024M10\n19\n\n\n2024M11\n19"
  },
  {
    "objectID": "muuttoliike.html",
    "href": "muuttoliike.html",
    "title": "Muuttoliike",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\n\n\n\n\n\n\n\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}\n\n\n\n\n\n\n\nMuuttoliike\n\n\nKuntien välinen muuttoliike\nYmpyrä kuvaa kuntien välistä muuttoliikettä. Vihreällä olevat kunnat ovat muuttovoittajien ja punaisella olevat häviäjiä. Siniset viivat ympyrän keskellä kuvaavat muuttovirtojen suuruutta. Voit zoomata ympyrää hiiren rullalla. Laittamalla hiiren osoitin kuvan päälle näet muuttojen suuruudet ja liikesuunnat.\n\ndata = (await FileAttachmentDynamic(migrationChordCSV).csv());\n\n\nchart_chord_d3(data, title_txt_chord,chart_width,chart_height)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDOM.download(() =&gt; serialize(chart_chord_d3(data, title_txt_chord,chart_width,chart_height)), title_txt_chord, \"Save as SVG\")"
  },
  {
    "objectID": "liikenne.html",
    "href": "liikenne.html",
    "title": "Liikenne",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "liikenne.html#liikennemäärät",
    "href": "liikenne.html#liikennemäärät",
    "title": "Liikenne",
    "section": "Liikennemäärät",
    "text": "Liikennemäärät\n\nKartta LAM-antureista\nFintraffic kerää tietoa tieliikenteestä liikenteen automaattisten mittausasemien (LAM) avulla. Klikkaamalla kartan nuppineulaa saat auki lähimpien LAM-anturien tiedot alueellasi. Mittausajankohtia verrataan neljän vuoden ajalta samaan päivämäärään (2024-01-20) Lähde: (Fintraffic.fi 2024)\n\n\n\n\n\n\n\n\nLiikennemäärä yhteensä\nLiikennettä oli ajanjaksolla 2024-01-20 suunnassa vt3 Nokia Rajasalmi -&gt; Vaasa yhteensä 2.387^{4}. Vastaavasti suunnassa vt3 Nokia Rajasalmi -&gt; Hämeenlinna yhteensä 2.2355^{4}.\n\n\n\n\n\n\n\n\nHenkilö- tai pakettiauto\nHenkilö- tai pakettiautoliikennettä oli suunnassa vt3 Nokia Rajasalmi -&gt; Vaasa yhteensä 2.1976^{4}. Suunnan vt3 Nokia Rajasalmi -&gt; Hämeenlinna liikennemäärä oli yhteensä 2.043^{4}.\n\n\n\n\n\n\n\n\nKuorma-autot\nKuorma-autojen liikennemäärä oli suunnassa vt3 Nokia Rajasalmi -&gt; Vaasa yhteensä 1787. Suunnan vt3 Nokia Rajasalmi -&gt; Hämeenlinna kuorma-automäärä oli yhteensä 1789.\n\n\n\n\n\n\n\n\nLinja-autot\nLinja-autoja liikkui suunnassa vt3 Nokia Rajasalmi -&gt; Vaasa yhteensä 33. Vastaavasti suunnassa vt3 Nokia Rajasalmi -&gt; Hämeenlinna linja-autoja oli yhteensä 36.\n\n\n\n\n\n\n\n\nHenkilöauto ja asuntovaunu\nAsuntovaunujen kanssa liikkuvia henkilöautoja oli suunnassa vt3 Nokia Rajasalmi -&gt; Vaasa yhteensä 74 ja suunnassa vt3 Nokia Rajasalmi -&gt; Hämeenlinna yhteensä 100.\n\n\n\n\n\n\n\n\nMoottoripyörät ja mopot\n\n\nHCT (High Capacity Truck)\nLyhenne HCT tulee sanoista High Capacity Transport. Lyhenne on kansainvälisesti vakiintunut termi sallittua pidemmille tai raskaammille yhdistelmille tieliikenteessä, joita ei kuitenkaan pidetä erikoiskuljetuksina."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Alkusanat",
    "section": "",
    "text": "Alkusanat\nKuukausiraportti tarjoaa tietoa väestöstä, työmarkkinoista, asumisesta, rakentamisesta ja taloudesta kuukausi tai neljännesvuositasolla. Tietolähteinä käytetään esimerkiksi Tilastokeskuksen ja Verohallinon tilastoaineistoa. Kuukausiraporttia kehitetään yhteistyössä kuntien kanssa.\nRaportti on ajettu tammikuussa, 2025\nRaportti on julkaistu (GNU.org 2024) lisenssin alla. Kuukausiraportti on html-muodossa. Malleja kuntakohtaisesta raporteista löytyy osoitteista:\n\nKangasala: https://kangasalakehitys.github.io/kuukausiraportti/\nAkaa: https://kangasalakehitys.github.io/akaa/\nJuupajoki: https://kangasalakehitys.github.io/juupajoki/\nKuhmoinen: https://kangasalakehitys.github.io/kuhmoinen/\nMasku: https://kangasalakehitys.github.io/masku/\nNousinen: https://kangasalakehitys.github.io/nousiainen/\nPälkäne: https://kangasalakehitys.github.io/palkane/\nParkano: https://kangasalakehitys.github.io/parkano/\nUrjala: https://kangasalakehitys.github.io/urjala/\nYlöjärvi: https://kangasalakehitys.github.io/ylojarvi/\n\n\n\n\n\n\nLähteet\n\nGNU.org. 2024. LGPL 2.1 lisenssi. GNU.org. https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html."
  },
  {
    "objectID": "asuminen.html",
    "href": "asuminen.html",
    "title": "Asuminen",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "asuminen.html#asuminen---asuntokunnat-talotyypeittäin",
    "href": "asuminen.html#asuminen---asuntokunnat-talotyypeittäin",
    "title": "Asuminen",
    "section": "Asuminen - Asuntokunnat talotyypeittäin",
    "text": "Asuminen - Asuntokunnat talotyypeittäin\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVuosineljännes\nYhteensä\nOmakoti- ja paritalot\nRivitalot\nKerrostalot\nMuut rakennukset\n\n\n\n\n2023Q4\n1861\n1605\n203\n19\n34\n\n\n2024Q1*\n1864\n1606\n204\n20\n34\n\n\n2024Q2*\n1865\n1607\n207\n20\n31\n\n\n2024Q3*\n1866\n1603\n212\n20\n31\n\n\n\n\n\n\n\n\nTalotyyppien %-osuudet asuntokunnissa\nAsuntokunnista 2024Q3* omakoti- ja paritaloissa asui 85.9 % (edell. 86.2). Rivitaloissa asuvien osuus oli 11.4% (edell. 11.1) ja kerrostaloissa 1.1% (edell. 1.1)."
  },
  {
    "objectID": "asuminen.html#asuminen---asuntokunnat-talotyypin-ja-koon-mukaan",
    "href": "asuminen.html#asuminen---asuntokunnat-talotyypin-ja-koon-mukaan",
    "title": "Asuminen",
    "section": "Asuminen - Asuntokunnat talotyypin ja koon mukaan",
    "text": "Asuminen - Asuntokunnat talotyypin ja koon mukaan\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVuosineljännes\nAsuntokunnan koko\nYhteensä\nOmakoti- ja paritalot\nRivitalot\nKerrostalot\nMuut rakennukset\n\n\n\n\n2023Q4\n1 henkilö\n566\n422\n119\n11\n14\n\n\n2023Q4\n2 henkilöä\n649\n569\n60\n5\n15\n\n\n2023Q4\n3 henkilöä\n268\n249\n16\n2\n1\n\n\n2023Q4\n4 henkilöä tai enemmän\n378\n365\n8\n1\n4\n\n\n2024Q1*\n1 henkilö\n568\n422\n121\n11\n14\n\n\n2024Q1*\n2 henkilöä\n646\n569\n58\n5\n14\n\n\n2024Q1*\n3 henkilöä\n270\n248\n17\n3\n2\n\n\n2024Q1*\n4 henkilöä tai enemmän\n380\n367\n8\n1\n4\n\n\n2024Q2*\n1 henkilö\n560\n414\n123\n11\n12\n\n\n2024Q2*\n2 henkilöä\n653\n575\n59\n5\n14\n\n\n2024Q2*\n3 henkilöä\n267\n245\n17\n3\n2\n\n\n2024Q2*\n4 henkilöä tai enemmän\n385\n373\n8\n1\n3\n\n\n2024Q3*\n1 henkilö\n561\n410\n127\n11\n13\n\n\n2024Q3*\n2 henkilöä\n656\n578\n59\n5\n14\n\n\n2024Q3*\n3 henkilöä\n272\n250\n18\n3\n1\n\n\n2024Q3*\n4 henkilöä tai enemmän\n377\n365\n8\n1\n3"
  },
  {
    "objectID": "aluetalous.html",
    "href": "aluetalous.html",
    "title": "Aluetalous ja yritystoiminta",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "aluetalous.html#aloittaneet-ja-lopettaneet-yritykset",
    "href": "aluetalous.html#aloittaneet-ja-lopettaneet-yritykset",
    "title": "Aluetalous ja yritystoiminta",
    "section": "Aloittaneet ja lopettaneet yritykset",
    "text": "Aloittaneet ja lopettaneet yritykset\n\n\n\n\n\n\n\nAloittaneet ja lopettaneet yritykset\nAloittaneita yrityksiä ajanjaksolla 2024Q3 oli yhteensä 5 (lukema 2024Q2: 8). . Lopettaneiden yritysten määrä oli samalla ajanjaksolla yhteensä 6 (lukema 2024Q2: 10)..\n\n\n\n\n\n\n\n\nVuosineljännes\nAloittaneet yritykset (lkm)\nLopettaneet yritykset (lkm)\n\n\n\n\n2018Q4\n5\n6\n\n\n2019Q1\n6\n2\n\n\n2019Q2\n3\n5\n\n\n2019Q3\n7\n4\n\n\n2019Q4\n5\n6\n\n\n2020Q1\n13\n5\n\n\n2020Q2\n16\n4\n\n\n2020Q3\n12\n3\n\n\n2020Q4\n8\n6\n\n\n2021Q1\n9\n3\n\n\n2021Q2\n6\n5\n\n\n2021Q3\n6\n4\n\n\n2021Q4\n8\n4\n\n\n2022Q1\n8\n5\n\n\n2022Q2\n13\n7\n\n\n2022Q3\n8\n6\n\n\n2022Q4\n10\n6\n\n\n2023Q1\n8\n8\n\n\n2023Q2\n8\n5\n\n\n2023Q3\n10\n5\n\n\n2023Q4\n8\n8\n\n\n2024Q1\n7\n8\n\n\n2024Q2\n8\n10\n\n\n2024Q3\n5\n6"
  },
  {
    "objectID": "aluetalous.html#avoimet-työpaikat-kuukauden-laskentapäivänä-lkm.",
    "href": "aluetalous.html#avoimet-työpaikat-kuukauden-laskentapäivänä-lkm.",
    "title": "Aluetalous ja yritystoiminta",
    "section": "Avoimet työpaikat kuukauden laskentapäivänä (lkm.)",
    "text": "Avoimet työpaikat kuukauden laskentapäivänä (lkm.)\n\n\n\n\n\n\n\nAvoimet työpaikat kuukauden laskentapäivänä (lkm.)\nAvoimia työpaikkoja oli 2024M11 yhteensä 0 (lukema 2024M10: NA).\n\n\n\n\n\n\n\n\nKuukausi\nAvoimet työpaikat kuukauden laskentapäivänä (lkm.)\n\n\n\n\n2022M12\n15\n\n\n2023M01\n46\n\n\n2023M02\n29\n\n\n2023M03\n37\n\n\n2023M04\n23\n\n\n2023M05\n13\n\n\n2023M06\n14\n\n\n2023M07\n9\n\n\n2023M08\n7\n\n\n2023M09\n12\n\n\n2023M10\n10\n\n\n2023M11\n8\n\n\n2023M12\n7\n\n\n2024M01\n10\n\n\n2024M02\n11\n\n\n2024M03\n10\n\n\n2024M04\n10\n\n\n2024M05\n9\n\n\n2024M06\nNA\n\n\n2024M07\n7\n\n\n2024M08\n5\n\n\n2024M09\nNA\n\n\n2024M10\nNA\n\n\n2024M11\n0"
  },
  {
    "objectID": "aluetalous.html#uudet-avoimet-työpaikat",
    "href": "aluetalous.html#uudet-avoimet-työpaikat",
    "title": "Aluetalous ja yritystoiminta",
    "section": "Uudet avoimet työpaikat",
    "text": "Uudet avoimet työpaikat\n\n\n\n\n\n\n\nAvoimet työpaikat kuukauden laskentapäivänä (lkm.)\nAvoimia työpaikkoja oli 2024M11 yhteensä NA (lukema 2024M10: 5).\n\n\n\n\n\n\n\n\nKuukausi\nUudet avoimet työpaikat kuukauden aikana (lkm.)\n\n\n\n\n2022M12\n16\n\n\n2023M01\n50\n\n\n2023M02\n25\n\n\n2023M03\n45\n\n\n2023M04\n26\n\n\n2023M05\n12\n\n\n2023M06\n14\n\n\n2023M07\n6\n\n\n2023M08\n8\n\n\n2023M09\n15\n\n\n2023M10\n8\n\n\n2023M11\n10\n\n\n2023M12\n6\n\n\n2024M01\n8\n\n\n2024M02\n15\n\n\n2024M03\n10\n\n\n2024M04\n11\n\n\n2024M05\n7\n\n\n2024M06\nNA\n\n\n2024M07\nNA\n\n\n2024M08\nNA\n\n\n2024M09\n0\n\n\n2024M10\n5\n\n\n2024M11\nNA"
  },
  {
    "objectID": "data/kunta_center.html",
    "href": "data/kunta_center.html",
    "title": "",
    "section": "",
    "text": "&lt;!DOCTYPE qgis PUBLIC ‘http://mrcc.com/qgis.dtd’ ‘SYSTEM’&gt;     \n\n\n                 0 0     false"
  },
  {
    "objectID": "kansainvalisyys.html",
    "href": "kansainvalisyys.html",
    "title": "Kansainvälisyys",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "kansainvalisyys.html#kansainvälisyys---maahanmuutto-ja-nettomaahanmuutto",
    "href": "kansainvalisyys.html#kansainvälisyys---maahanmuutto-ja-nettomaahanmuutto",
    "title": "Kansainvälisyys",
    "section": "Kansainvälisyys - Maahanmuutto ja nettomaahanmuutto",
    "text": "Kansainvälisyys - Maahanmuutto ja nettomaahanmuutto\n\n\n\n\n\n\n\nMaahanmuutto ja nettomaahanmuutto\nKumulatiivinen nettomaahanmuutto oli vuoden alusta tähän hetkeen 2024M12* yhteensä 5. Edellisvuoden lukema nettomaahanmuutossa oli -10. Erotusta nettomaahanmuutossa viime vuoteen on yhteensä 15 henkilöä. Pohjoismaista oli muuttanut yhteensä yhteensä 2 henkilöä ja muista EU-maista 5 henkilöä. Kokonaisuudessaan maahanmuuttajia oli yhteensä 14.\nNettomaahanmuutto (tai nettosiirtolaisuus) on maahanmuuton ja maastamuuton erotus. Lähde: Tilastokeskus\n\n\n\n\n\n\n\n\nVuosi\nMaahanmuutto Suomeen\nMaahanmuutto Suomeen Pohjoismaista\nMaahanmuutto Suomeen EU-maista\nNettomaahanmuutto\n\n\n\n\n2015\n2\n0\n0\n-10\n\n\n2016\n17\n7\n13\n9\n\n\n2017\n5\n2\n3\n3\n\n\n2018\n15\n2\n12\n10\n\n\n2019\n2\n0\n2\n-6\n\n\n2020\n5\n1\n3\n1\n\n\n2021\n9\n2\n6\n7\n\n\n2022\n3\n1\n2\n-1\n\n\n2023\n0\n0\n0\n-10\n\n\n2024M12*\n14\n2\n5\n5"
  },
  {
    "objectID": "maps/pienalue2024.html",
    "href": "maps/pienalue2024.html",
    "title": "",
    "section": "",
    "text": "&lt;!DOCTYPE qgis PUBLIC ‘http://mrcc.com/qgis.dtd’ ‘SYSTEM’&gt;  Tilastollinen_aluejako_2021_alkaen  FIN dataset\n\nTilastollinen_aluejako_2021_alkaen\n\n               PROJCRS[“ETRS89 / GK24FIN”,BASEGEOGCRS[“ETRS89”,ENSEMBLE[“European Terrestrial Reference System 1989 ensemble”,MEMBER[“European Terrestrial Reference Frame 1989”],MEMBER[“European Terrestrial Reference Frame 1990”],MEMBER[“European Terrestrial Reference Frame 1991”],MEMBER[“European Terrestrial Reference Frame 1992”],MEMBER[“European Terrestrial Reference Frame 1993”],MEMBER[“European Terrestrial Reference Frame 1994”],MEMBER[“European Terrestrial Reference Frame 1996”],MEMBER[“European Terrestrial Reference Frame 1997”],MEMBER[“European Terrestrial Reference Frame 2000”],MEMBER[“European Terrestrial Reference Frame 2005”],MEMBER[“European Terrestrial Reference Frame 2014”],ELLIPSOID[“GRS 1980”,6378137,298.257222101,LENGTHUNIT[“metre”,1]],ENSEMBLEACCURACY[0.1]],PRIMEM[“Greenwich”,0,ANGLEUNIT[“degree”,0.0174532925199433]],ID[“EPSG”,4258]],CONVERSION[“Finland Gauss-Kruger zone 24”,METHOD[“Transverse Mercator”,ID[“EPSG”,9807]],PARAMETER[“Latitude of natural origin”,0,ANGLEUNIT[“degree”,0.0174532925199433],ID[“EPSG”,8801]],PARAMETER[“Longitude of natural origin”,24,ANGLEUNIT[“degree”,0.0174532925199433],ID[“EPSG”,8802]],PARAMETER[“Scale factor at natural origin”,1,SCALEUNIT[“unity”,1],ID[“EPSG”,8805]],PARAMETER[“False easting”,24500000,LENGTHUNIT[“metre”,1],ID[“EPSG”,8806]],PARAMETER[“False northing”,0,LENGTHUNIT[“metre”,1],ID[“EPSG”,8807]]],CS[Cartesian,2],AXIS[“northing (N)”,north,ORDER[1],LENGTHUNIT[“metre”,1]],AXIS[“easting (E)”,east,ORDER[2],LENGTHUNIT[“metre”,1]],USAGE[SCOPE[“Cadastre, engineering survey, topographic mapping (large scale).”],AREA[“Finland - nominally onshore between 23�30’E and 24�30’E but may be used in adjacent areas if a municipality chooses to use one zone over its whole extent.”],BBOX[59.86,23.5,68.84,24.5]],ID[“EPSG”,3878]] +proj=tmerc +lat_0=0 +lon_0=24 +k=1 +x_0=24500000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs 27312 3878 EPSG:3878 ETRS89 / GK24FIN tmerc EPSG:7019 false"
  },
  {
    "objectID": "syntyvyys.html",
    "href": "syntyvyys.html",
    "title": "Syntyvyys",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "syntyvyys.html#luonnollinen-väestönkasvu",
    "href": "syntyvyys.html#luonnollinen-väestönkasvu",
    "title": "Syntyvyys",
    "section": "Luonnollinen väestönkasvu",
    "text": "Luonnollinen väestönkasvu\n\nLuonnollinen väestönlisäys\n\n\n\n\n\n\nSyntyneiden enemmyys eli luonnollinen väestönlisäys tarkoittaa elävänä syntyneiden ja kuolleiden erotusta.\nLuonnollinen väestönlisäys ajanjaksolla 2024Q3* - 2024Q4* oli yhteensä 1 (2024Q3*: 4). Vuosina 2022 ja 2023 luonnollinen väestönlisäys oli 2022: -11 ja 2023: -21\n\n\n\n\n\n\n\n\nVuosi\nEnnakkotieto\n\n\n\n\n2013\nNA\n\n\n2014\nNA\n\n\n2015\nNA\n\n\n2016\nNA\n\n\n2017\nNA\n\n\n2018\nNA\n\n\n2019\nNA\n\n\n2020\nNA\n\n\n2021\nNA\n\n\n2022\nNA\n\n\n2023\nNA\n\n\n2024Q1*\n2\n\n\n2024Q2*\n-3\n\n\n2024Q3*\n4\n\n\n2024Q4*\n-2"
  },
  {
    "objectID": "syntyvyys.html#syntyneet",
    "href": "syntyvyys.html#syntyneet",
    "title": "Syntyvyys",
    "section": "Syntyneet",
    "text": "Syntyneet\n\nSyntyvyys\n\n\n\n\n\n\n\n\nSyntyvyys\nSyntyvyys ajanjaksolla 2024Q3* - 2024Q4* oli yhteensä 31 (lukema 2024Q3* oli 8). Vuosina 2022 ja 2023 syntyvyys oli lukemissa (2022) 34 ja (2023) 38.\n\n\n\n\n\n\n\n\nVuosi\nEnnakkotieto\n\n\n\n\n2013\nNA\n\n\n2014\nNA\n\n\n2015\nNA\n\n\n2016\nNA\n\n\n2017\nNA\n\n\n2018\nNA\n\n\n2019\nNA\n\n\n2020\nNA\n\n\n2021\nNA\n\n\n2022\nNA\n\n\n2023\nNA\n\n\n2024Q1*\n10\n\n\n2024Q2*\n7\n\n\n2024Q3*\n8\n\n\n2024Q4*\n6"
  },
  {
    "objectID": "syntyvyys.html#väestönmuutokset---väestöpyramidi",
    "href": "syntyvyys.html#väestönmuutokset---väestöpyramidi",
    "title": "Syntyvyys",
    "section": "Väestönmuutokset - Väestöpyramidi",
    "text": "Väestönmuutokset - Väestöpyramidi\n\nDOM.download(() =&gt; serialize(pyramid), \"Väestöpyramidi\", \"Save as SVG\")\n\n\n\n\n\n\n\npyramid_pop_data = FileAttachmentDynamic(pyramid_pop_csv).csv({typed: true})\n\ntranslations = ({\n  v1990: \"1990\",\n  v2010: \"2010\",\n  v2024: valitut_kk_tahti\n  })\n\npyramid = toSVG(Plot.plot({\n  width: 600,\n  height: 600,\n  marginTop: 20,\n  marginRight: 20,\n  marginBottom: 30,\n  marginLeft: 40,\n  x: {\n    label: \"← mies · väestö · nainen →\",\n    labelAnchor: \"center\",\n    tickFormat: Math.abs,\n    //domain: [-300, 300]\n  },\n  y: {grid: true},\n  color: {\n    width: 300,\n    domain: [\"v1990\", \"v2010\", \"v2024\"],\n    range: [\"#e41a1c\", \"#377eb8\", \"#4daf4a\"],\n    legend: true,\n    className: 'large-font',\n    tickFormat: (d) =&gt; translations[d]\n  },\n  style: {\n    fontSize: 14\n  },\n  marks: [\n    Plot.lineX(pyramid_pop_data, {\n      x: (d) =&gt; d.population * (d.sex === \"Miehet\" ? -1 : 1),\n      y: \"age\",\n      z: (d) =&gt; [d.sex, d.category].join(\",\"),\n      stroke: \"category\",\n      strokeWidth: 4,\n      fill: \"category\",\n      fillOpacity: 0\n    }),\n    Plot.ruleX([0]),\n    Plot.ruleY([0])\n  ]\n}))"
  },
  {
    "objectID": "vaesto.html",
    "href": "vaesto.html",
    "title": "Väestönmuutokset",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "vaesto.html#kuntien-välinen-nettomuutto---viimeiset-12kk",
    "href": "vaesto.html#kuntien-välinen-nettomuutto---viimeiset-12kk",
    "title": "Väestönmuutokset",
    "section": "Kuntien välinen nettomuutto - viimeiset 12kk",
    "text": "Kuntien välinen nettomuutto - viimeiset 12kk\nVoit tarkistella karttaa tarkemmin pyörittämällä hiiren rullanäppäintä.\n\ndata_migr = (await FileAttachmentDynamic(migrBetwMuniMapCSV).csv()).map((d) =&gt; (d.muutos = +d.muutos, d))\n\n//Väritetään kartta\nmapInterpolateRdBu_migr = d3.scaleDiverging([-150, 0, 150], d3.interpolatePiYG);\n\nborderColorDark_migr = \"#525252\";\n\n//Piirretään kartta\nchart_map_d3(data_migr, mapTopoJSON, mapInterpolateRdBu_migr, borderColorDark_migr, title_txt_map_migr,chart_width_migr,chart_height_migr)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDOM.download(() =&gt; serialize(chart_map_d3(data_migr, mapTopoJSON, mapInterpolateRdBu_migr, borderColorDark_migr, title_txt_map_migr,chart_width_migr,chart_height_migr)), title_txt_map_migr, \"Save as SVG\")\n\n\n\n\n\n\n\n\n\nKuntien välinen nettomuutto - viimeiset 12kk\n\n\n\n\n\n\n\n\nSija\nMaakunta\nKunta\nKuntien välinen nettomuutto\n\n\n\n\n1\nUusimaa\nHelsinki\n3283\n\n\n2\nPirkanmaa\nTampere\n2711\n\n\n3\nUusimaa\nEspoo\n1887\n\n\n4\nVarsinais-Suomi\nTurku\n1611\n\n\n5\nUusimaa\nTuusula\n740\n\n\n6\nPirkanmaa\nNokia\n483\n\n\n7\nPirkanmaa\nKangasala\n418\n\n\n8\nPohjois-Savo\nKuopio\n386\n\n\n9\nPirkanmaa\nPirkkala\n202\n\n\n10\nUusimaa\nSipoo\n171\n\n\n11\nUusimaa\nLohja\n151\n\n\n12\nUusimaa\nKirkkonummi\n129\n\n\n13\nVarsinais-Suomi\nKaarina\n124\n\n\n14\nVarsinais-Suomi\nNaantali\n111\n\n\n15\nLappi\nInari\n77\n\n\n16\nUusimaa\nKerava\n75\n\n\n17\nSatakunta\nPori\n75\n\n\n18\nVarsinais-Suomi\nRaisio\n67\n\n\n19\nAhvenanmaa\nJomala\n65\n\n\n20\nPirkanmaa\nOrivesi\n58\n\n\n21\nPäijät-Häme\nHeinola\n53\n\n\n22\nUusimaa\nPorvoo\n53\n\n\n23\nKeski-Suomi\nMuurame\n50\n\n\n24\nPirkanmaa\nHämeenkyrö\n43\n\n\n25\nUusimaa\nHyvinkää\n43\n\n\n26\nEtelä-Savo\nMäntyharju\n42\n\n\n27\nPäijät-Häme\nHollola\n41\n\n\n28\nPirkanmaa\nVesilahti\n40\n\n\n29\nUusimaa\nInkoo\n36\n\n\n30\nPirkanmaa\nAkaa\n34\n\n\n31\nPohjois-Karjala\nIlomantsi\n34\n\n\n32\nUusimaa\nHanko\n27\n\n\n33\nKeski-Pohjanmaa\nKannus\n26\n\n\n34\nPohjois-Savo\nTuusniemi\n26\n\n\n35\nPäijät-Häme\nIitti\n25\n\n\n36\nEtelä-Pohjanmaa\nIlmajoki\n25\n\n\n37\nKeski-Suomi\nUurainen\n25\n\n\n38\nPohjois-Pohjanmaa\nIi\n23\n\n\n39\nUusimaa\nSiuntio\n23\n\n\n40\nPohjois-Pohjanmaa\nVaala\n23\n\n\n41\nEtelä-Savo\nHirvensalmi\n22\n\n\n42\nPohjois-Savo\nLeppävirta\n22\n\n\n43\nEtelä-Karjala\nRuokolahti\n21\n\n\n44\nPohjois-Pohjanmaa\nSiikalatva\n21\n\n\n45\nEtelä-Savo\nSulkava\n20\n\n\n46\nPohjois-Pohjanmaa\nKempele\n19\n\n\n47\nVarsinais-Suomi\nKustavi\n19\n\n\n48\nLappi\nSodankylä\n19\n\n\n49\nKeski-Pohjanmaa\nPerho\n18\n\n\n50\nEtelä-Savo\nPuumala\n17\n\n\n\n\n\n\n\n\n\nKuntien välinen nettomuutto - viimeiset 12kk, top20\nVesilahti on sijalla 28, tarkasteltaessa kuntien välistä nettomuuttoa viimeisen 12kk aikana. Kuntien välinen nettomuuttolukema on 40. Maakuntavertailussa (Pirkanmaa) Vesilahti on sijalla 7."
  },
  {
    "objectID": "vaesto.html#väestönmuutokset---väestöennakko",
    "href": "vaesto.html#väestönmuutokset---väestöennakko",
    "title": "Väestönmuutokset",
    "section": "Väestönmuutokset - Väestöennakko",
    "text": "Väestönmuutokset - Väestöennakko\n\n\n\n\n\n\n\nEnnakkotiedot\nEnnakkotietojen (2024M12) perusteella väkiluku on kasvanut 0.16 % (2024M11: -0.09 %). Uusin väestön ennakkotieto on 4515 (edell. lukema 4508). Vuoden alusta (2023: 4469) väkiluku on kasvanut 1.03 %.\n\n\n\n\n\n\n\n\nVuosi\nEnnakkotieto\n\n\n\n\n2021\nNA\n\n\n2022\nNA\n\n\n2023\nNA\n\n\n2024M01*\n4479\n\n\n2024M02*\n4481\n\n\n2024M03*\n4496\n\n\n2024M04*\n4502\n\n\n2024M05*\n4518\n\n\n2024M06*\n4513\n\n\n2024M07*\n4517\n\n\n2024M08*\n4496\n\n\n2024M09*\n4517\n\n\n2024M10*\n4512\n\n\n2024M11*\n4508\n\n\n2024M12*\n4515"
  },
  {
    "objectID": "vaesto.html#väkiluvun-muutos--vuoden-2023-lopusta",
    "href": "vaesto.html#väkiluvun-muutos--vuoden-2023-lopusta",
    "title": "Väestönmuutokset",
    "section": "Väkiluvun muutos-% vuoden 2023 lopusta",
    "text": "Väkiluvun muutos-% vuoden 2023 lopusta\nVoit tarkistella kartaa lähemmin pyörittämällä hiiren rullanäppäintä.\n\ndata = (await FileAttachmentDynamic(populationMapCSV).csv()).map((d) =&gt; (d.muutos = +d.muutos, d))\n\n//Väritetään kartta\n//mapInterpolateRdBu = d3.scaleDiverging([domain_min, 0, domain_max], d3.interpolateRdBu);\nmapInterpolateRdBu = d3.scaleDiverging([-1.5, 0, 1.5], d3.interpolatePiYG);\n\nborderColorDark = \"#525252\";\n\n//Piirretään kartta\nchart_map_d3(data, mapTopoJSON, mapInterpolateRdBu, borderColorDark, title_txt_map,chart_width,chart_height)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDOM.download(() =&gt; serialize(chart_map_d3(data, mapTopoJSON, mapInterpolateRdBu, borderColorDark, title_txt_map,chart_width,chart_height)), title_txt_map, \"Save as SVG\")"
  },
  {
    "objectID": "vaesto.html#väkiluvun-muutos--edellisvuoden-lopusta",
    "href": "vaesto.html#väkiluvun-muutos--edellisvuoden-lopusta",
    "title": "Väestönmuutokset",
    "section": "Väkiluvun muutos-% edellisvuoden lopusta",
    "text": "Väkiluvun muutos-% edellisvuoden lopusta\n\n\n\n\n\n\n\n\nSija\nMaakunta\nKunta\nVäestö 31.12.\n2024M12*\nMuutos-%\n\n\n\n\n1\nPohjanmaa\nKaskinen\n1208\n1240\n2.65\n\n\n2\nUusimaa\nEspoo\n314024\n321031\n2.23\n\n\n3\nUusimaa\nTuusula\n41338\n42238\n2.18\n\n\n4\nPirkanmaa\nTampere\n255050\n260358\n2.08\n\n\n5\nVarsinais-Suomi\nTurku\n201863\n206035\n2.07\n\n\n6\nPohjanmaa\nVaasa\n68956\n70374\n2.06\n\n\n7\nVarsinais-Suomi\nKustavi\n949\n967\n1.90\n\n\n8\nAhvenanmaa\nJomala\n5697\n5794\n1.70\n\n\n9\nUusimaa\nVantaa\n247443\n251405\n1.60\n\n\n10\nAhvenanmaa\nEckerö\n942\n957\n1.59\n\n\n11\nVarsinais-Suomi\nRaisio\n25331\n25717\n1.52\n\n\n12\nUusimaa\nHelsinki\n674500\n684589\n1.50\n\n\n13\nPirkanmaa\nKangasala\n33473\n33966\n1.47\n\n\n14\nPirkanmaa\nNokia\n35647\n36171\n1.47\n\n\n15\nLappi\nInari\n7127\n7226\n1.39\n\n\n16\nAhvenanmaa\nLumparland\n366\n371\n1.37\n\n\n17\nPohjois-Savo\nKuopio\n124021\n125668\n1.33\n\n\n18\nPirkanmaa\nPirkkala\n20763\n21034\n1.31\n\n\n19\nKeski-Suomi\nLuhanka\n702\n711\n1.28\n\n\n20\nUusimaa\nKirkkonummi\n41154\n41660\n1.23\n\n\n21\nAhvenanmaa\nGeta\n509\n515\n1.18\n\n\n22\nKeski-Suomi\nUurainen\n3615\n3655\n1.11\n\n\n23\nKeski-Suomi\nJyväskylä\n147746\n149269\n1.03\n\n\n24\nPirkanmaa\nVesilahti\n4469\n4515\n1.03\n\n\n25\nUusimaa\nSipoo\n22595\n22823\n1.01\n\n\n26\nUusimaa\nPorvoo\n51289\n51753\n0.90\n\n\n27\nAhvenanmaa\nKökar\n225\n227\n0.89\n\n\n28\nPohjois-Karjala\nJoensuu\n78062\n78743\n0.87\n\n\n29\nUusimaa\nJärvenpää\n46490\n46866\n0.81\n\n\n30\nEtelä-Savo\nPieksämäki\n17050\n17186\n0.80\n\n\n31\nAhvenanmaa\nMaarianhamina - Mariehamn\n11812\n11898\n0.73\n\n\n32\nPohjois-Pohjanmaa\nOulu\n214633\n216194\n0.73\n\n\n33\nPohjois-Pohjanmaa\nKempele\n19514\n19652\n0.71\n\n\n34\nUusimaa\nKerava\n38211\n38476\n0.69\n\n\n35\nLappi\nRovaniemi\n65286\n65738\n0.69\n\n\n36\nPirkanmaa\nValkeakoski\n20694\n20837\n0.69\n\n\n37\nSatakunta\nKankaanpää\n12394\n12478\n0.68\n\n\n38\nEtelä-Pohjanmaa\nSeinäjoki\n66160\n66610\n0.68\n\n\n39\nEtelä-Pohjanmaa\nIlmajoki\n12343\n12426\n0.67\n\n\n40\nPohjanmaa\nLuoto\n5843\n5881\n0.65\n\n\n41\nVarsinais-Suomi\nKaarina\n36339\n36563\n0.62\n\n\n42\nAhvenanmaa\nSund\n995\n1001\n0.60\n\n\n43\nKeski-Suomi\nLaukaa\n18762\n18873\n0.59\n\n\n44\nKanta-Häme\nRiihimäki\n28483\n28650\n0.59\n\n\n45\nPäijät-Häme\nLahti\n120693\n121383\n0.57\n\n\n46\nVarsinais-Suomi\nLaitila\n8441\n8488\n0.56\n\n\n47\nVarsinais-Suomi\nNaantali\n19999\n20108\n0.55\n\n\n48\nPohjois-Karjala\nOutokumpu\n6409\n6444\n0.55\n\n\n49\nUusimaa\nNurmijärvi\n44785\n45026\n0.54\n\n\n50\nEtelä-Karjala\nLappeenranta\n72988\n73369\n0.52\n\n\n\n\n\n\n\n\nVäkiluvun muutos-% edellisvuoden lopusta\nVesilahti on sijalla 24, tarkasteltaessa väkiluvun muutosta edellisvuoden lopusta kuntien kesken. Viimeisin ennakkotietolukema on 4515 (muutos-% edellisen vuoden loppuun: 1.03). Maakuntavertailussa (Pirkanmaa) Vesilahti on sijalla 5."
  },
  {
    "objectID": "vaesto.html#väestönmuutokset---väestöennakko-viisi-ikäluokkaa",
    "href": "vaesto.html#väestönmuutokset---väestöennakko-viisi-ikäluokkaa",
    "title": "Väestönmuutokset",
    "section": "Väestönmuutokset - Väestöennakko, viisi ikäluokkaa",
    "text": "Väestönmuutokset - Väestöennakko, viisi ikäluokkaa\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVuosi\nYhteensä\n0-6\n0-6 %\n7-15\n7-15 %\n16-64\n16-64 %\n65-79\n65-79 %\n80+\n80+ %\n\n\n\n\n2000\n3421\n331\n9.68\n465\n13.59\n2015\n58.90\n486\n14.21\n124\n3.62\n\n\n2001\n3481\n344\n9.88\n480\n13.79\n2043\n58.69\n479\n13.76\n135\n3.88\n\n\n2002\n3596\n385\n10.71\n489\n13.60\n2103\n58.48\n474\n13.18\n145\n4.03\n\n\n2003\n3663\n395\n10.78\n514\n14.03\n2151\n58.72\n457\n12.48\n146\n3.99\n\n\n2004\n3675\n390\n10.61\n533\n14.50\n2140\n58.23\n468\n12.73\n144\n3.92\n\n\n2005\n3831\n419\n10.94\n561\n14.64\n2227\n58.13\n466\n12.16\n158\n4.12\n\n\n2006\n3949\n415\n10.51\n576\n14.59\n2323\n58.83\n473\n11.98\n162\n4.10\n\n\n2007\n4086\n442\n10.82\n587\n14.37\n2413\n59.06\n478\n11.70\n166\n4.06\n\n\n2008\n4248\n483\n11.37\n590\n13.89\n2526\n59.46\n477\n11.23\n172\n4.05\n\n\n2009\n4365\n485\n11.11\n613\n14.04\n2616\n59.93\n463\n10.61\n188\n4.31\n\n\n2010\n4345\n471\n10.84\n630\n14.50\n2574\n59.24\n483\n11.12\n187\n4.30\n\n\n2011\n4383\n475\n10.84\n646\n14.74\n2578\n58.82\n485\n11.07\n199\n4.54\n\n\n2012\n4437\n464\n10.46\n659\n14.85\n2629\n59.25\n485\n10.93\n200\n4.51\n\n\n2013\n4473\n448\n10.02\n678\n15.16\n2628\n58.75\n510\n11.40\n209\n4.67\n\n\n2014\n4492\n449\n10.00\n681\n15.16\n2618\n58.28\n533\n11.87\n211\n4.70\n\n\n2015\n4489\n421\n9.38\n670\n14.93\n2634\n58.68\n536\n11.94\n228\n5.08\n\n\n2016\n4462\n393\n8.81\n672\n15.06\n2631\n58.96\n541\n12.12\n225\n5.04\n\n\n2017\n4460\n382\n8.57\n674\n15.11\n2612\n58.57\n574\n12.87\n218\n4.89\n\n\n2018\n4393\n356\n8.10\n645\n14.68\n2585\n58.84\n596\n13.57\n211\n4.80\n\n\n2019\n4355\n329\n7.55\n633\n14.54\n2575\n59.13\n602\n13.82\n216\n4.96\n\n\n2020\n4367\n301\n6.89\n629\n14.40\n2616\n59.90\n611\n13.99\n210\n4.81\n\n\n2021\n4444\n313\n7.04\n610\n13.73\n2667\n60.01\n641\n14.42\n213\n4.79\n\n\n2022\n4501\n319\n7.09\n611\n13.57\n2700\n59.99\n664\n14.75\n207\n4.60\n\n\n2023\n4469\n311\n6.96\n608\n13.60\n2676\n59.88\n680\n15.22\n194\n4.34\n\n\n2024M12*\n4515\n314\n6.95\n604\n13.38\n2695\n59.69\n706\n15.64\n196\n4.34\n\n\n\n\n\n\n\n\nVäestökehityksen muutos - 5 ikäluokkaa\n\n0-6-vuotiaat\nIkäluokkien kehitystä aikaisempiin vuosiin vertailtaessa 0-6-vuotiaiden %-osuus oli 2024M12* yhteensä 6.95. Jos verrataan lukemaa kahteen edellisvuoteen 2022 ja 2023, muutosta on tullut -0.14 (2022) ja -0.01 (2023)\n\n\n7-15-vuotiaat\n7-15-vuotiaiden %-osuus oli 2024M12* yhteensä 13.38. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut -0.19 (2022) ja -0.22 (2023)\n\n\n16-64-vuotiaat\nIkäluokka 16-64-vuotiaat on suurin kooltaan. Tämän ryhmän prosenttiosuus kokonaisuudesta oli 2024M12* yhteensä 59.69. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut -0.3 (2022) ja -0.19 (2023)\n\n\n65-79-vuotiaat\nIkäluokka 65-79-vuotiaat oli kooltaan 2024M12* yhteensä 15.64. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.89 (2022) ja 0.42 (2023)\n\n\n80+-vuotiaat\n80+-vuotiaiden %-osuus oli 2024M12* yhteensä 4.34. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut -0.26 (2022) ja 0 (2023)"
  },
  {
    "objectID": "vaesto.html#väestönmuutokset---väestöennakko-kuusi-ikäluokkaa",
    "href": "vaesto.html#väestönmuutokset---väestöennakko-kuusi-ikäluokkaa",
    "title": "Väestönmuutokset",
    "section": "Väestönmuutokset - Väestöennakko, kuusi ikäluokkaa",
    "text": "Väestönmuutokset - Väestöennakko, kuusi ikäluokkaa\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVuosi\nYhteensä\n0-6\n0-6 %\n7-15\n7-15 %\n16-18\n16-18 %\n19-64\n19-64 %\n65-79\n65-79 %\n80+\n80+ %\n\n\n\n\n2000\n3421\n331\n9.68\n465\n13.59\n105\n3.07\n1910\n55.83\n486\n14.21\n124\n3.62\n\n\n2001\n3481\n344\n9.88\n480\n13.79\n115\n3.30\n1928\n55.39\n479\n13.76\n135\n3.88\n\n\n2002\n3596\n385\n10.71\n489\n13.60\n114\n3.17\n1989\n55.31\n474\n13.18\n145\n4.03\n\n\n2003\n3663\n395\n10.78\n514\n14.03\n113\n3.08\n2038\n55.64\n457\n12.48\n146\n3.99\n\n\n2004\n3675\n390\n10.61\n533\n14.50\n103\n2.80\n2037\n55.43\n468\n12.73\n144\n3.92\n\n\n2005\n3831\n419\n10.94\n561\n14.64\n118\n3.08\n2109\n55.05\n466\n12.16\n158\n4.12\n\n\n2006\n3949\n415\n10.51\n576\n14.59\n147\n3.72\n2176\n55.10\n473\n11.98\n162\n4.10\n\n\n2007\n4086\n442\n10.82\n587\n14.37\n161\n3.94\n2252\n55.12\n478\n11.70\n166\n4.06\n\n\n2008\n4248\n483\n11.37\n590\n13.89\n180\n4.24\n2346\n55.23\n477\n11.23\n172\n4.05\n\n\n2009\n4365\n485\n11.11\n613\n14.04\n175\n4.01\n2441\n55.92\n463\n10.61\n188\n4.31\n\n\n2010\n4345\n471\n10.84\n630\n14.50\n167\n3.84\n2407\n55.40\n483\n11.12\n187\n4.30\n\n\n2011\n4383\n475\n10.84\n646\n14.74\n149\n3.40\n2429\n55.42\n485\n11.07\n199\n4.54\n\n\n2012\n4437\n464\n10.46\n659\n14.85\n151\n3.40\n2478\n55.85\n485\n10.93\n200\n4.51\n\n\n2013\n4473\n448\n10.02\n678\n15.16\n166\n3.71\n2462\n55.04\n510\n11.40\n209\n4.67\n\n\n2014\n4492\n449\n10.00\n681\n15.16\n179\n3.98\n2439\n54.30\n533\n11.87\n211\n4.70\n\n\n2015\n4489\n421\n9.38\n670\n14.93\n196\n4.37\n2438\n54.31\n536\n11.94\n228\n5.08\n\n\n2016\n4462\n393\n8.81\n672\n15.06\n187\n4.19\n2444\n54.77\n541\n12.12\n225\n5.04\n\n\n2017\n4460\n382\n8.57\n674\n15.11\n194\n4.35\n2418\n54.22\n574\n12.87\n218\n4.89\n\n\n2018\n4393\n356\n8.10\n645\n14.68\n191\n4.35\n2394\n54.50\n596\n13.57\n211\n4.80\n\n\n2019\n4355\n329\n7.55\n633\n14.54\n191\n4.39\n2384\n54.74\n602\n13.82\n216\n4.96\n\n\n2020\n4367\n301\n6.89\n629\n14.40\n199\n4.56\n2417\n55.35\n611\n13.99\n210\n4.81\n\n\n2021\n4444\n313\n7.04\n610\n13.73\n196\n4.41\n2471\n55.60\n641\n14.42\n213\n4.79\n\n\n2022\n4501\n319\n7.09\n611\n13.57\n200\n4.44\n2500\n55.54\n664\n14.75\n207\n4.60\n\n\n2023\n4469\n311\n6.96\n608\n13.60\n187\n4.18\n2489\n55.69\n680\n15.22\n194\n4.34\n\n\n2024M12*\n4515\n314\n6.95\n604\n13.38\n199\n4.41\n2496\n55.28\n706\n15.64\n196\n4.34\n\n\n\n\n\n\n\n\nVäestökehityksen muutos - 6 ikäluokkaa\n\n0-6-vuotiaat\nIkäluokkien kehitystä aikaisempiin vuosiin vertailtaessa 0-6-vuotiaiden %-osuus oli 2024M12* yhteensä 6.95. Jos verrataan lukemaa kahteen edellisvuoteen 2022 ja 2023, muutosta on tullut -0.14 (2022) ja -0.01 (2023)\n\n\n7-15-vuotiaat\n7-15-vuotiaiden %-osuus oli 2024M12* yhteensä 13.38. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut -0.19 (2022) ja -0.22 (2023)\n\n\n16-18-vuotiaat\n16-18-vuotiaiden prosenttiosuus kokonaisuudesta oli 2024M12* yhteensä 4.41. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut -0.03 (2022) ja 0.23 (2023)\n\n\n18-64-vuotiaat\nIkäluokka 18-64-vuotiaat on suurin kooltaan. Tämän ryhmän prosenttiosuus kokonaisuudesta oli 2024M12* yhteensä 59.69. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut **** (2022) ja **** (2023)\n\n\n65-79-vuotiaat\nIkäluokka 65-79-vuotiaat oli kooltaan 2024M12* yhteensä 15.64. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.89 (2022) ja 0.42 (2023)\n\n\n80+-vuotiaat\n80+-vuotiaiden %-osuus oli 2024M12* yhteensä 4.34. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut -0.26 (2022) ja 0 (2023)"
  }
]